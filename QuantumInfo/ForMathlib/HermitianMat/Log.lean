/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c56fa2bb-94d1-4207-a086-9c4fed170aec

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove `log_kron`, stating that the matrix logarithm of the Kronecker product of two positive definite Hermitian matrices is the sum of the Kronecker products of their logarithms with the identity matrix.
This relies on the spectral theorem to simultaneously diagonalize the matrices, and the fact that the logarithm of a diagonal matrix is the diagonal matrix of the logarithms.
We also prove helper lemmas about the behavior of `HermitianMat.conj`, `HermitianMat.kronecker`, and `HermitianMat.diagonalRCLike`.
-/

/-
Copyright (c) 2025 Alex Meiburg. All rights reserved.
Released under MIT license as described in the file LICENSE.
Authors: Alex Meiburg
-/
import QuantumInfo.ForMathlib.HermitianMat.CfcOrder
import QuantumInfo.ForMathlib.HermitianMat.Proj
import Batteries.Tactic.ShowUnused

/-! # Properties of the matrix logarithm

In particular, operator monotonicity and concavity of the matrix logarithm.
These are proved using `inv_antitone`, so, first showing that the matrix inverse
is operator antitone for positive definite matrices.
-/

variable {m n ğ•œ : Type*} [Fintype n] [DecidableEq n] [Fintype m] [DecidableEq m] [RCLike ğ•œ]
variable {A B : HermitianMat n ğ•œ} {x : â„}

theorem Matrix.IsHermitian.log_smul_of_ne_zero {A : Matrix n n ğ•œ} (hA : A.IsHermitian) (hx : x â‰  0) :
    cfc Real.log (x â€¢ A) = (Real.log x) â€¢ cfc (if Â· = 0 then (0 : â„) else 1) A + cfc Real.log A := by
  have hCFC : cfc (Real.log âˆ˜ (x * Â·)) A = cfc Real.log (x â€¢ A) := by
    exact cfc_comp_smul x Real.log _ (by fun_prop) hA
  rw [â† hCFC, â† cfc_smul, â† cfc_add]
  apply cfc_congr
  intro t ht
  by_cases h : t = 0
  Â· simp [*]
  Â· simp [*, Real.log_mul]

namespace HermitianMat

@[simp]
theorem log_zero : (0 : HermitianMat n ğ•œ).log = 0 := by
  simp [log, cfc]

@[simp]
theorem log_one : (1 : HermitianMat n ğ•œ).log = 0 := by
  simp [log, cfc]

theorem log_smul_of_pos (A : HermitianMat n ğ•œ) (hx : x â‰  0) :
    (x â€¢ A).log = Real.log x â€¢ A.supportProj + A.log := by
  ext1
  convert A.H.log_smul_of_ne_zero hx
  simp [cfc, log, supportProj_eq_cfc]

theorem log_smul {A : HermitianMat n ğ•œ} {x : â„} (hx : x â‰  0) [NonSingular A] :
    (x â€¢ A).log = Real.log x â€¢ 1 + A.log := by
  simp [log_smul_of_pos A hx]

/-
The inverse function is operator antitone for positive definite matrices.
-/
open ComplexOrder in
theorem inv_antitone (hA : A.mat.PosDef) (h : A â‰¤ B) : Bâ»Â¹ â‰¤ Aâ»Â¹ := by
  -- Since $B - A$ is positive semidefinite, we can write it as $C^*C$ for some matrix $C$.
  obtain âŸ¨C, hCâŸ© : âˆƒ C : Matrix n n ğ•œ, B.mat - A.mat = C.conjTranspose * C :=
    Matrix.posSemidef_iff_eq_conjTranspose_mul_self.mp h
  -- Using the fact that $B = A + C^*C$, we can write $B^{-1}$ as $(A + C^*C)^{-1}$.
  have h_inv_posDef : (1 + C * A.matâ»Â¹ * C.conjTranspose).PosDef := by
    exact Matrix.PosDef.one.add_posSemidef (hA.inv.posSemidef.mul_mul_conjTranspose_same C)
  have hB_inv : B.matâ»Â¹ = A.matâ»Â¹ - A.matâ»Â¹ * C.conjTranspose * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ * C * A.matâ»Â¹ := by
    have hB_inv : (A.mat + C.conjTranspose * C)â»Â¹ = A.matâ»Â¹ - A.matâ»Â¹ * C.conjTranspose * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ * C * A.matâ»Â¹ := by
      have hB_inv : (A.mat + C.conjTranspose * C) * (A.matâ»Â¹ - A.matâ»Â¹ * C.conjTranspose * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ * C * A.matâ»Â¹) = 1 := by
        have h_inv : (1 + C * A.matâ»Â¹ * C.conjTranspose) * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ = 1 := by
          exact Matrix.mul_nonsing_inv _ ( show IsUnit _ from by simpa [ Matrix.isUnit_iff_isUnit_det ] using h_inv_posDef.det_pos.ne' );
        simp only [mul_assoc, Matrix.mul_sub] at *
        simp only [â† Matrix.mul_assoc, add_mul, one_mul] at *
        simp only [isUnit_iff_ne_zero, ne_eq, hA.det_pos.ne', not_false_eq_true,
          Matrix.mul_nonsing_inv, one_mul, â† add_mul] at *
        simp only [mul_assoc, add_mul] at *
        simp_all only [â† Matrix.mul_assoc, â† eq_sub_iff_add_eq']
        grind only [cases eager Subtype]
      rw [ Matrix.inv_eq_right_inv hB_inv ];
    rw [ â† hB_inv, â† hC, add_sub_cancel ];
  -- Since $(1 + C * Aâ»Â¹ * C.conjTranspose)$ is positive definite, its inverse is also positive definite.
  have h_inv_pos : (A.matâ»Â¹ * C.conjTranspose * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ * C * A.matâ»Â¹).PosSemidef := by
    have h_inv_pos : (C * A.matâ»Â¹).conjTranspose * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ * (C * A.matâ»Â¹) = A.matâ»Â¹ * C.conjTranspose * (1 + C * A.matâ»Â¹ * C.conjTranspose)â»Â¹ * C * A.matâ»Â¹ := by
      simp [ Matrix.mul_assoc, Matrix.conjTranspose_mul ];
      rw [ Matrix.conjTranspose_nonsing_inv, A.H ];
    rw [ â† h_inv_pos ];
    exact Matrix.PosSemidef.conjTranspose_mul_mul_same h_inv_posDef.inv.posSemidef _
  have h_inv_pos : (A.matâ»Â¹ - B.matâ»Â¹).PosSemidef := by
    simp_all [ Matrix.PosSemidef ];
  exact h_inv_pos

/-
The integral of $1/(1+t) - 1/(x+t)$ from 0 to T is $\log x + \log((1+T)/(x+T))$.
-/
lemma Real.integral_inv_sub_inv_finite (x T : â„) (hx : 0 < x) (hT : 0 < T) :
    âˆ« t in (0)..T, (1 / (1 + t) - 1 / (x + t)) = Real.log x + Real.log ((1 + T) / (x + T)) := by
  rw [ intervalIntegral.integral_sub, intervalIntegral.integral_comp_add_left, intervalIntegral.integral_comp_add_left ];
  Â· rw [ â† Real.log_mul, intervalIntegral.integral_deriv_eq_sub' ];
    field_simp;
    rw [ intervalIntegral.integral_deriv_eq_sub' ];
    any_goals intro t ht; exact Real.differentiableAt_log ( by cases Set.mem_uIcc.mp ht <;> linarith );
    any_goals positivity;
    Â· rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_mul ( by positivity ) ( by positivity ) ] ; norm_num;
      ring;
    Â· exact funext fun x => by simp [ div_eq_inv_mul ] ;
    Â· exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const continuousAt_id ( by cases Set.mem_uIcc.mp ht <;> linarith );
    Â· exact funext fun x => by simp [ div_eq_inv_mul ] ;
    Â· exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const continuousAt_id <| by cases Set.mem_uIcc.mp ht <;> linarith;
  Â· exact ContinuousOn.intervalIntegrable ( by exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( continuousAt_const.add continuousAt_id ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ hT.le ] using ht ) ] ) );
  Â· exact ContinuousOn.intervalIntegrable ( by exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( continuousAt_const.add continuousAt_id ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ hT.le ] using ht ) ] ) )

/--
The limit of $\log((1+T)/(x+T))$ as $T \to \infty$ is 0, for $x > 0$.
-/
lemma Real.tendsto_log_div_add_atTop (x : â„) :
    Filter.Tendsto (fun T => Real.log ((1 + T) / (x + T))) .atTop (nhds 0) := by
  -- We can divide the numerator and the denominator by $b$ and then take the limit as $b$ approaches infinity.
  suffices h_div : Filter.Tendsto (fun b => Real.log ((1 / b + 1) / (x / b + 1))) Filter.atTop (nhds 0) by
    refine h_div.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with b hb using by rw [ show ( 1 + b ) / ( x + b ) = ( 1 / b + 1 ) / ( x / b + 1 ) by rw [ div_add_one, div_add_one, div_div_div_cancel_rightâ‚€ ] <;> positivity ] );
  exact le_trans ( Filter.Tendsto.log ( Filter.Tendsto.div ( Filter.Tendsto.add ( tendsto_const_nhds.div_atTop Filter.tendsto_id ) tendsto_const_nhds ) ( Filter.Tendsto.add ( tendsto_const_nhds.div_atTop Filter.tendsto_id ) tendsto_const_nhds ) ( by positivity ) ) ( by positivity ) ) ( by norm_num )

open ComplexOrder

set_option maxHeartbeats 1000000 in
open ComplexOrder MeasureTheory intervalIntegral in
/--
Monotonicity of the finite integral approximation of the logarithm.
-/
theorem logApprox_mono {x y : HermitianMat n ğ•œ} (hx : x.mat.PosDef) (hy : y.mat.PosDef)
    (hxy : x â‰¤ y) (T : â„) (hT : 0 < T) :
    âˆ« t in (0)..T, ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (x + t â€¢ 1)â»Â¹) â‰¤
    âˆ« t in (0)..T, ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (y + t â€¢ 1)â»Â¹) := by
  have h_integral_limit : âˆ€ t âˆˆ Set.Icc (0 : â„) T, (y + t â€¢ 1)â»Â¹ â‰¤ (x + t â€¢ 1)â»Â¹ := by
    intro t ht;
    apply inv_antitone;
    Â· constructor;
      Â· simp [ Matrix.IsHermitian];
      Â· intro v hv_ne_zero
        have h_pos : 0 < star v â¬áµ¥ x.mat.mulVec v + t * star v â¬áµ¥ v := by
          have := hx.2 v hv_ne_zero;
          exact add_pos_of_pos_of_nonneg this ( mul_nonneg ( mod_cast ht.1 ) ( dotProduct_star_self_nonneg v ) );
        simp_all [ Matrix.add_mulVec ];
        convert h_pos using 2 ; simp [ Matrix.mulVec, dotProduct ];
        simp [ Matrix.one_apply, Finset.mul_sum, mul_left_comm ];
        simp [ mul_left_comm, Algebra.smul_def ];
    Â· exact add_le_add_right hxy _;
  -- By the properties of the integral, we can bring the limit inside, so we have:
  have h_integral_limit : âˆ« t in (0)..T, (1 + t)â»Â¹ â€¢ 1 - (x + t â€¢ 1)â»Â¹ â‰¤ âˆ« t in (0)..T, (1 + t)â»Â¹ â€¢ 1 - (y + t â€¢ 1)â»Â¹ := by
    have h_integrable : ContinuousOn (fun t : â„ => (1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ)) (Set.Icc 0 T) âˆ§ ContinuousOn (fun t : â„ => (x + t â€¢ 1)â»Â¹) (Set.Icc 0 T) âˆ§ ContinuousOn (fun t : â„ => (y + t â€¢ 1)â»Â¹) (Set.Icc 0 T) := by
      refine' âŸ¨ ContinuousOn.smul ( ContinuousOn.invâ‚€ ( continuousOn_const.add continuousOn_id ) fun t ht => by linarith [ ht.1 ] ) continuousOn_const, _, _ âŸ©;
      Â· refine' ContinuousOn.comp ( show ContinuousOn ( fun m : HermitianMat n ğ•œ => mâ»Â¹ ) ( { m : HermitianMat n ğ•œ | m.mat.PosDef } ) from _ ) _ _;
        Â· intro m hm;
          refine' ContinuousAt.continuousWithinAt _;
          have h_inv_cont : ContinuousAt (fun m : Matrix n n ğ•œ => mâ»Â¹) m.mat := by
            have h_inv_cont : ContinuousAt (fun m : Matrix n n ğ•œ => mâ»Â¹) m.mat := by
              have h_det_cont : ContinuousAt (fun m : Matrix n n ğ•œ => m.det) m.mat := by
                exact Continuous.continuousAt ( continuous_id.matrix_det )
              have h_adj_cont : ContinuousAt (fun m : Matrix n n ğ•œ => m.adjugate) m.mat := by
                exact Continuous.continuousAt ( continuous_id.matrix_adjugate )
              simp_all [ Matrix.inv_def ];
              exact ContinuousAt.smul ( h_det_cont.invâ‚€ ( by simpa using hm.det_pos.ne' ) ) h_adj_cont;
            exact h_inv_cont;
          rw [ ContinuousAt ] at *;
          rw [ tendsto_subtype_rng ] at *;
          exact h_inv_cont.comp ( continuous_subtype_val.tendsto _ );
        Â· fun_prop;
        Â· intro t ht;
          refine' âŸ¨ _, _ âŸ©;
          Â· exact H ((fun t => x + t â€¢ 1) t);
          Â· intro v hv_ne_zero
            have h_pos : 0 < star v â¬áµ¥ x.mat.mulVec v + t * star v â¬áµ¥ (1 : Matrix n n ğ•œ).mulVec v := by
              have := hx.2 v hv_ne_zero;
              refine' add_pos_of_pos_of_nonneg this _;
              exact mul_nonneg ( mod_cast ht.1 ) ( Finset.sum_nonneg fun i _ => by simp [ mul_comm, RCLike.mul_conj ] );
            simp_all [ Matrix.add_mulVec ];
            simp_all [ Matrix.mulVec, dotProduct ];
            simp_all [ Matrix.one_apply, Finset.mul_sum, mul_left_comm,];
            convert h_pos using 3 ; simp [ mul_left_comm, Algebra.smul_def ];
      Â· have h_cont : ContinuousOn (fun t : â„ => (y + t â€¢ 1 : Matrix n n ğ•œ)â»Â¹) (Set.Icc 0 T) := by
          have h_inv : âˆ€ t âˆˆ Set.Icc 0 T, (y + t â€¢ 1 : Matrix n n ğ•œ).det â‰  0 := by
            intro t ht;
            have h_det_pos : âˆ€ t âˆˆ Set.Icc (0 : â„) T, Matrix.PosDef (y.mat + t â€¢ 1) := by
              intro t ht;
              refine' âŸ¨ _, _ âŸ©;
              Â· simp [ Matrix.IsHermitian, Matrix.conjTranspose_add, Matrix.conjTranspose_smul ];
              Â· intro x hx_ne_zero
                have h_pos : 0 < star x â¬áµ¥ y.mat.mulVec x + t * star x â¬áµ¥ x := by
                  have := hy.2 x hx_ne_zero;
                  exact add_pos_of_pos_of_nonneg this ( mul_nonneg ( mod_cast ht.1 ) ( by simp [ dotProduct_comm ] ) );
                simp_all [ Matrix.add_mulVec ]
                simp_all [ Matrix.mulVec, dotProduct ]
                simp_all [ Matrix.one_apply, Finset.mul_sum, mul_left_comm ]
                convert h_pos using 1;
                simp [ mul_assoc, mul_comm, mul_left_comm, Algebra.smul_def ];
            exact ne_of_gt ( h_det_pos t ht |> fun h => h.det_pos )
          have h_cont_inv : ContinuousOn (fun t : â„ => (y + t â€¢ 1 : Matrix n n ğ•œ)â»Â¹) (Set.Icc 0 T) := by
            have h_cont_det : ContinuousOn (fun t : â„ => (y + t â€¢ 1 : Matrix n n ğ•œ).det) (Set.Icc 0 T) := by
              fun_prop
            have h_cont_adj : ContinuousOn (fun t : â„ => (y + t â€¢ 1 : Matrix n n ğ•œ).adjugate) (Set.Icc 0 T) := by
              fun_prop;
            simp_all [ Matrix.inv_def ];
            exact ContinuousOn.smul ( h_cont_det.invâ‚€ fun t ht => h_inv t ht.1 ht.2 ) h_cont_adj;
          convert h_cont_inv using 1;
        rw [ continuousOn_iff_continuous_restrict ] at *;
        exact continuous_induced_rng.mpr h_cont
    rw [ intervalIntegral.integral_of_le hT.le, intervalIntegral.integral_of_le hT.le ];
    have h_integral_limit : âˆ€ t âˆˆ Set.Ioc 0 T, (1 + t)â»Â¹ â€¢ 1 - (x + t â€¢ 1)â»Â¹ â‰¤ (1 + t)â»Â¹ â€¢ 1 - (y + t â€¢ 1)â»Â¹ := by
      exact fun t ht => sub_le_sub_left ( h_integral_limit t <| Set.Ioc_subset_Icc_self ht ) _;
    apply_rules [ MeasureTheory.integral_mono_ae ];
    Â· exact ContinuousOn.integrableOn_Icc (ContinuousOn.sub h_integrable.1 h_integrable.2.1) |> fun h => h.mono_set (Set.Ioc_subset_Icc_self);
    Â· exact ContinuousOn.integrableOn_Icc (ContinuousOn.sub h_integrable.1 h_integrable.2.2) |> fun h => h.mono_set (Set.Ioc_subset_Icc_self);
    Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_integral_limit t ht;
  exact h_integral_limit

/-
Definition of the finite integral approximation of the logarithm.
-/
noncomputable def logApprox {n ğ•œ : Type*} [Fintype n] [DecidableEq n] [RCLike ğ•œ]
    (x : HermitianMat n ğ•œ) (T : â„) : HermitianMat n ğ•œ :=
  âˆ« t in (0)..T, ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (x + t â€¢ 1)â»Â¹)

/-
Definition of the scalar log approximation and its value.
-/
noncomputable def scalarLogApprox (T : â„) (u : â„) : â„ :=
  âˆ« t in (0)..T, ((1 + t)â»Â¹ - (u + t)â»Â¹)

theorem scalarLogApprox_eq (x T : â„) (hx : 0 < x) (hT : 0 < T) :
    scalarLogApprox T x = Real.log x + Real.log ((1 + T) / (x + T)) := by
  convert Real.integral_inv_sub_inv_finite x T hx hT using 1;
  unfold scalarLogApprox; norm_num

open ComplexOrder in
/--
The integrand in the log approximation is the CFC of the scalar integrand.
-/
private lemma integrand_eq
    (x : HermitianMat n ğ•œ) (hx : x.mat.PosDef) (t : â„) (ht : 0 â‰¤ t) :
    ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (x + t â€¢ 1)â»Â¹) = cfc x (fun u => (1 + t)â»Â¹ - (u + t)â»Â¹) := by
  have h_cfc_add : cfc x (fun u => u + t) = cfc x (fun u => u) + cfc x (fun u => t) :=
    x.cfc_add id _
  have h_cfc_sub : (x + t â€¢ 1)â»Â¹ = cfc x (fun u => (u + t)â»Â¹) := by
    convert inv_cfc_eq_cfc_inv (fun u => u + t) ?_ using 1;
    Â· simp [h_cfc_add]
    Â· exact fun i => ne_of_gt ( add_pos_of_pos_of_nonneg ( hx.eigenvalues_pos i ) ht );
  rw [â† cfc_const x (1 + t)â»Â¹, h_cfc_sub, â† cfc_sub ];
  rfl

open ComplexOrder MeasureTheory intervalIntegral in
/--
The matrix log approximation is the CFC of the scalar log approximation.
-/
theorem logApprox_eq_cfc_scalar
    (x : HermitianMat n ğ•œ) (hx : x.mat.PosDef) (T : â„) (hT : 0 < T) :
    logApprox x T = cfc x (scalarLogApprox T) := by
  unfold scalarLogApprox logApprox;
  rw [ intervalIntegral.integral_congr fun t ht => ?_ ];
  convert integral_cfc_eq_cfc_integral 0 T ( fun t u => ( 1 + t ) â»Â¹ - ( u + t ) â»Â¹ ) ?_ using 1;
  Â· intro i;
    apply_rules [ ContinuousOn.intervalIntegrable ];
    field_simp;
    apply_rules [ ContinuousOn.sub, ContinuousOn.div, continuousOn_const, continuousOn_id ];
    Â· fun_prop;
    Â· exact fun x hx => by cases Set.mem_uIcc.mp hx <;> linarith;
    Â· fun_prop;
    Â· have := hx.eigenvalues_pos i;
      exact fun t ht => ne_of_gt ( add_pos_of_pos_of_nonneg this ( by cases Set.mem_uIcc.mp ht <;> linarith ) );
  Â· convert integrand_eq x hx t ( by cases Set.mem_uIcc.mp ht <;> linarith )

open ComplexOrder in
/--
The log approximation is the log plus an error term.
-/
theorem logApprox_eq_log_add_error {n ğ•œ : Type*} [Fintype n] [DecidableEq n] [RCLike ğ•œ]
    (x : HermitianMat n ğ•œ) (hx : x.mat.PosDef) (T : â„) (hT : 0 < T) :
    logApprox x T = x.log + cfc x (fun u => Real.log ((1 + T) / (u + T))) := by
  have h_logApprox : âˆ« t in (0)..T, ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (x + t â€¢ 1)â»Â¹) = cfc x (fun u => Real.log u + Real.log ((1 + T) / (u + T))) := by
    convert logApprox_eq_cfc_scalar x hx T hT using 1;
    apply cfc_congr_of_posDef hx;
    exact fun u hu => Eq.symm ( scalarLogApprox_eq u T hu.out hT );
  have h_cfc_add : cfc x (fun u => Real.log u + Real.log ((1 + T) / (u + T))) = cfc x Real.log + cfc x (fun u => Real.log ((1 + T) / (u + T))) := by
    apply cfc_add;
  exact h_logApprox.trans h_cfc_add

open ComplexOrder Filter Topology in
open scoped Matrix.Norms.Frobenius in
/--
The error term in the log approximation tends to 0 as T goes to infinity.
-/
lemma tendsto_cfc_log_div_add_atTop {n ğ•œ : Type*} [Fintype n] [DecidableEq n] [RCLike ğ•œ]
    (x : HermitianMat n ğ•œ) :
    Tendsto (fun T => cfc x (fun u => Real.log ((1 + T) / (u + T)))) atTop (nhds 0) := by
  -- Expand `(cfc x ...).mat` using `cfc_toMat_eq_sum_smul_proj`.
  have h_expand : âˆ€ T : â„, ((cfc x (fun u => Real.log ((1 + T) / (u + T)))).mat) = âˆ‘ i, Real.log ((1 + T) / (x.H.eigenvalues i + T)) â€¢ (x.H.eigenvectorUnitary.val * (Matrix.single i i 1) * x.H.eigenvectorUnitary.val.conjTranspose) := by
    exact fun T => cfc_toMat_eq_sum_smul_proj x fun u => Real.log ((1 + T) / (u + T));
  -- The limit of a sum is the sum of the limits.
  have h_sum : Filter.Tendsto (fun T : â„ => âˆ‘ i, Real.log ((1 + T) / (x.H.eigenvalues i + T)) â€¢ (x.H.eigenvectorUnitary.val * (Matrix.single i i 1) * x.H.eigenvectorUnitary.val.conjTranspose)) Filter.atTop (nhds (âˆ‘ i, 0 â€¢ (x.H.eigenvectorUnitary.val * (Matrix.single i i 1) * x.H.eigenvectorUnitary.val.conjTranspose))) := by
    refine' tendsto_finset_sum _ fun i _ => _;
    convert Filter.Tendsto.smul_const ( Real.tendsto_log_div_add_atTop ( x.H.eigenvalues i ) ) _ using 1;
    all_goals try infer_instance;
    norm_num +zetaDelta at *
  rw [ tendsto_iff_norm_sub_tendsto_zero ] at *;
  convert h_sum using 2 ; simp [ â† h_expand]
  rfl

open ComplexOrder Filter in
/--
The log approximation converges to the matrix logarithm.
-/
lemma tendsto_logApprox {n ğ•œ : Type*} [Fintype n] [DecidableEq n] [RCLike ğ•œ]
    {x : HermitianMat n ğ•œ} (hx : x.mat.PosDef) :
  Tendsto (fun T => logApprox x T) atTop (nhds x.log) := by
    have h_log_approx_eq : âˆ€á¶  T in Filter.atTop, x.logApprox T = x.log + cfc x (fun u => Real.log ((1 + T) / (u + T))) := by
      filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using logApprox_eq_log_add_error x hx T hT;
    rw [ Filter.tendsto_congr' h_log_approx_eq ];
    simpa using tendsto_const_nhds.add ( tendsto_cfc_log_div_add_atTop x )

open ComplexOrder in
/--
The matrix logarithm is operator monotone.
-/
theorem log_mono (hA : A.mat.PosDef) (hB : B.mat.PosDef)
    (hAB : A â‰¤ B) : A.log â‰¤ B.log := by
  apply le_of_tendsto_of_tendsto (tendsto_logApprox hA) (tendsto_logApprox hB)
  rw [Filter.EventuallyLE, Filter.eventually_atTop]
  exact âŸ¨1, fun T hT => by simpa using logApprox_mono hA hB hAB T ( zero_lt_one.trans_le hT )âŸ©

set_option maxHeartbeats 10000000 in
open ComplexOrder Matrix in
/--
The inverse function is operator convex on positive definite matrices.
-/
lemma inv_convex {x y : HermitianMat n ğ•œ} (hx : x.mat.PosDef) (hy : y.mat.PosDef)
    â¦ƒa b : â„â¦„ (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
    (a â€¢ x + b â€¢ y)â»Â¹ â‰¤ a â€¢ xâ»Â¹ + b â€¢ yâ»Â¹ := by
  -- Using the fact that the set of positive semidefinite matrices is a convex cone, we can show that the matrix
  -- $\begin{pmatrix} a \bullet x + b \bullet y & I \\ I & a \bullet x^{-1} + b \bullet y^{-1} \end{pmatrix}$
  -- is positive semidefinite.
  have h_pos_semidef :
    (Matrix.fromBlocks (a â€¢ x.mat + b â€¢ y.mat) (1 : Matrix n n ğ•œ) (1 : Matrix n n ğ•œ) (a â€¢ (x.mat)â»Â¹ + b â€¢ (y.mat)â»Â¹)).PosSemidef := by
      -- Since $a + b = 1$, we can use the fact that the block matrix $\begin{pmatrix} A & I \\ I & A^{-1} \end{pmatrix}$ is positive semidefinite for any positive definite $A$.
      have h_block_pos : âˆ€ A : Matrix n n ğ•œ, A.PosDef â†’ (Matrix.fromBlocks A 1 1 Aâ»Â¹).PosSemidef := by
        intro A hA
        have h_block_pos : (Matrix.fromBlocks A (1 : Matrix n n ğ•œ) (1 : Matrix n n ğ•œ) (Aâ»Â¹)).PosSemidef := by
          have h_inv_pos : Aâ»Â¹.PosSemidef := by
            exact hA.inv.posSemidef
          have h_block_pos : (Matrix.fromBlocks A (1 : Matrix n n ğ•œ) (1 : Matrix n n ğ•œ) (Aâ»Â¹)) = (Matrix.fromBlocks 1 0 Aâ»Â¹ 1) * (Matrix.fromBlocks A 0 0 (Aâ»Â¹ - Aâ»Â¹ * A * Aâ»Â¹)) * (Matrix.fromBlocks 1 Aâ»Â¹ 0 1) := by
            simp [ Matrix.fromBlocks_multiply ];
            have := hA.det_pos;
            exact âŸ¨ by rw [ Matrix.mul_nonsing_inv _ ( show IsUnit A.det from isUnit_iff_ne_zero.mpr this.ne' ) ], by rw [ Matrix.nonsing_inv_mul _ ( show IsUnit A.det from isUnit_iff_ne_zero.mpr this.ne' ) ] âŸ©;
          have h_block_pos : (Matrix.fromBlocks A 0 0 (Aâ»Â¹ - Aâ»Â¹ * A * Aâ»Â¹)).PosSemidef := by
            have h_block_pos : (Matrix.fromBlocks A 0 0 (Aâ»Â¹ - Aâ»Â¹ * A * Aâ»Â¹)) = (Matrix.fromBlocks A 0 0 0) := by
              have h_inv : Aâ»Â¹ * A = 1 := by
                rw [ Matrix.nonsing_inv_mul _ ];
                exact isUnit_iff_ne_zero.mpr hA.det_pos.ne';
              simp [ h_inv ];
            rw [h_block_pos];
            constructor;
            Â· ext i j ; simp [ Matrix.fromBlocks ];
              cases i <;> cases j <;> simp
              exact hA.1.apply _ _;
            Â· intro x
              simp [Matrix.mulVec, dotProduct];
              have := hA.2 ( fun i => x ( Sum.inl i ) );
              by_cases h : ( fun i => x ( Sum.inl i ) ) = 0 <;> simp_all [ dotProduct, Matrix.mulVec ];
              Â· simp_all [ funext_iff ];
              Â· exact le_of_lt this;
          rw [ Matrix.PosSemidef ] at *;
          simp_all [ Matrix.IsHermitian, Matrix.mul_assoc ];
          refine' âŸ¨ _, _ âŸ©;
          Â· simp [Matrix.fromBlocks_conjTranspose, h_inv_pos.1 ];
          Â· intro x
            set y : n âŠ• n â†’ ğ•œ := (Matrix.fromBlocks 1 Aâ»Â¹ 0 1).mulVec x
            have h_y : star x â¬áµ¥ (Matrix.fromBlocks 1 0 Aâ»Â¹ 1 * (Matrix.fromBlocks A 0 0 (Aâ»Â¹ - Aâ»Â¹ * (A * Aâ»Â¹)) * Matrix.fromBlocks 1 Aâ»Â¹ 0 1)).mulVec x = star y â¬áµ¥ (Matrix.fromBlocks A 0 0 (Aâ»Â¹ - Aâ»Â¹ * (A * Aâ»Â¹))).mulVec y := by
              simp +zetaDelta at *;
              simp [Matrix.dotProduct_mulVec ];
              simp [ Matrix.star_mulVec ];
              congr! 2;
              ext i j ; simp [ Matrix.mul_apply, Matrix.fromBlocks ];
              cases i <;> cases j <;> simp [ Matrix.one_apply];
              Â· rw [ â† Matrix.ext_iff ] at * ; aesop;
              Â· rw [ â† Matrix.ext_iff ] at * ; aesop;
            exact h_y.symm â–¸ h_block_pos.2 y;
        exact h_block_pos;
      -- Since $a + b = 1$, we can use the fact that the block matrix $\begin{pmatrix} a \bullet x + b \bullet y & I \\ I & a \bullet x^{-1} + b \bullet y^{-1} \end{pmatrix}$ is positive semidefinite.
      have h_convex : Matrix.PosSemidef ((a â€¢ Matrix.fromBlocks (x.mat) (1 : Matrix n n ğ•œ) (1 : Matrix n n ğ•œ) (x.mat)â»Â¹) + (b â€¢ Matrix.fromBlocks (y.mat) (1 : Matrix n n ğ•œ) (1 : Matrix n n ğ•œ) (y.mat)â»Â¹)) := by
        apply_rules [ Matrix.PosSemidef.add, Matrix.PosSemidef.smul ];
      convert h_convex using 1;
      ext i j ; simp [ Matrix.fromBlocks ];
      rcases i with ( i | i ) <;> rcases j with ( j | j ) <;> simp [ Matrix.one_apply ];
      Â· split_ifs <;> simp_all [ â† add_smul ];
      Â· split_ifs <;> simp_all [ â† add_smul ];
  have h_schur : (a â€¢ x.mat + b â€¢ y.mat).PosDef := by
    by_cases ha' : a = 0 <;> by_cases hb' : b = 0 <;> simp_all [ Matrix.PosSemidef ];
    constructor;
    Â· simp_all [ Matrix.IsHermitian, Matrix.conjTranspose_add, Matrix.conjTranspose_smul ];
    Â· intro v hv_ne_zero
      have h_pos : 0 < a * (star v â¬áµ¥ x.mat.mulVec v) + b * (star v â¬áµ¥ y.mat.mulVec v) := by
        have := hx.2 v hv_ne_zero; have := hy.2 v hv_ne_zero; simp_all [ Matrix.mulVec, dotProduct ] ;
        exact add_pos_of_nonneg_of_pos ( mul_nonneg ( mod_cast ha ) ( le_of_lt â€¹_â€º ) ) ( mul_pos ( mod_cast lt_of_le_of_ne hb ( Ne.symm hb' ) ) ( mod_cast this ) );
      convert h_pos using 1 ; simp [ Matrix.add_mulVec]
      ring_nf
      simp [ Matrix.mulVec, dotProduct, Finset.mul_sum, mul_left_comm];
      simp [mul_left_comm, Algebra.smul_def ];
  change (a â€¢ (x.mat)â»Â¹ + b â€¢ (y.mat)â»Â¹ - (a â€¢ x.mat + b â€¢ y.mat)â»Â¹).PosSemidef
  refine' âŸ¨ _, fun v => _ âŸ©;
  Â· simp_all [ Matrix.IsHermitian, Matrix.conjTranspose_nonsing_inv ];
  Â· have := h_pos_semidef.2;
    specialize this (Sum.elim (- (a â€¢ x.mat + b â€¢ y.mat)â»Â¹.mulVec v) v);
    simp_all [ Matrix.fromBlocks_mulVec ];
    simp_all [ Matrix.mul_nonsing_inv _ ( show IsUnit ( Matrix.det ( a â€¢ ( x : Matrix n n ğ•œ ) + b â€¢ ( y : Matrix n n ğ•œ ) ) ) from isUnit_iff_ne_zero.mpr <| h_schur.det_pos.ne' ), Matrix.mulVec_neg];
    simp_all [ dotProduct, Matrix.sub_mulVec ];
    exact this.trans_eq ( Finset.sum_congr rfl fun _ _ => by ring );

/--
The shifted inverse function is operator convex.
-/
lemma inv_shift_convex {x y : HermitianMat n ğ•œ} (hx : x.mat.PosDef) (hy : y.mat.PosDef)
    â¦ƒa b : â„â¦„ (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) (t : â„) (ht : 0 â‰¤ t) :
    (a â€¢ x + b â€¢ y + t â€¢ 1)â»Â¹ â‰¤ a â€¢ (x + t â€¢ 1)â»Â¹ + b â€¢ (y + t â€¢ 1)â»Â¹ := by
  have hx' : (x + t â€¢ 1).mat.PosDef := hx.add_posSemidef (.smul .one ht)
  have hy' : (y + t â€¢ 1).mat.PosDef := hy.add_posSemidef (.smul .one ht)
  convert inv_convex hx' hy' ha hb hab using 1
  ext
  simp [add_assoc, add_left_comm, hab, â† add_smul]

open MeasureTheory intervalIntegral ComplexOrder Matrix in
open scoped Matrix.Norms.Frobenius in
/--
Definition of the approximation of the matrix logarithm.
-/
lemma integrable_inv_shift {A : HermitianMat n ğ•œ} (hA : A.mat.PosDef) (b : â„) (hb : 0 â‰¤ b) :
    IntervalIntegrable (fun t => (A + t â€¢ 1)â»Â¹) volume 0 b := by
  -- The function $t \mapsto (A + tI)^{-1}$ is continuous on $[0, b]$ because $A + tI$ is invertible for all $t \geq 0$.
  have h_cont : ContinuousOn (fun t : â„ => (A + t â€¢ 1 : HermitianMat n ğ•œ)â»Â¹) (Set.Icc 0 b) := by
    have h_cont : ContinuousOn (fun t : â„ => (A + t â€¢ 1 : Matrix n n ğ•œ)â»Â¹) (Set.Icc 0 b) := by
      have h_inv : âˆ€ t âˆˆ Set.Icc 0 b, IsUnit (A + t â€¢ 1 : Matrix n n ğ•œ) := by
        intro t ht
        have h_pos_def : Matrix.PosDef (A + t â€¢ 1 : Matrix n n ğ•œ) := by
          simp_all [ Matrix.PosDef ];
          simp_all [ Matrix.IsHermitian, Matrix.add_mulVec ]
          intro x hx; specialize hA x hx; simp_all [ Matrix.mulVec, dotProduct ];
          simp_all [ Matrix.one_apply, Finset.mul_sum ];
          apply add_pos_of_pos_of_nonneg hA
          refine Finset.sum_nonneg fun i _ â†¦ ?_
          simp [ Algebra.smul_def, mul_comm ];
          apply mul_nonneg (by simp [RCLike.mul_conj])
          simpa using ht.1
        exact h_pos_def.isUnit
      have h_cont_inv : ContinuousOn (fun t : â„ => (A + t â€¢ 1 : Matrix n n ğ•œ).detâ»Â¹) (Set.Icc 0 b) := by
        apply ContinuousOn.invâ‚€ (by fun_prop)
        exact (Matrix.det_ne_zero_of_left_inverse <| h_inv Â· Â· |>.unit.inv_mul)
      simp [Matrix.inv_def]
      fun_prop
    rw [continuousOn_iff_continuous_restrict] at *
    exact continuous_induced_rng.mpr h_cont
  exact h_cont.intervalIntegrable_of_Icc hb

open ComplexOrder in
/--
The finite integral approximation of the matrix logarithm is operator concave.
-/
theorem logApprox_concave {n ğ•œ : Type*} [Fintype n] [DecidableEq n] [RCLike ğ•œ]
    {x y : HermitianMat n ğ•œ} (hx : x.mat.PosDef) (hy : y.mat.PosDef)
    â¦ƒa b : â„â¦„ (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) (T : â„) (hT : 0 â‰¤ T) :
    a â€¢ x.logApprox T + b â€¢ y.logApprox T â‰¤ (a â€¢ x + b â€¢ y).logApprox T := by
  have h_integrable {z : HermitianMat n ğ•œ} : z.mat.PosDef â†’ IntervalIntegrable (fun t => (1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (z + t â€¢ 1)â»Â¹) MeasureTheory.volume 0 T := by
    intro hz
    have h_integrable := integrable_inv_shift hz T hT
    rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hT ] at *
    refine MeasureTheory.Integrable.sub ?_ h_integrable
    exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.smul ( ContinuousAt.invâ‚€ ( continuousAt_const.add continuousAt_id ) ( by linarith [ ht.1 ] ) ) continuousAt_const ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
  have h_int2 : IntervalIntegrable (fun t => (1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - ((a â€¢ x + b â€¢ y) + t â€¢ 1)â»Â¹) MeasureTheory.volume 0 T := by
    exact h_integrable (Matrix.PosDef.Convex hx hy ha hb hab)
  have h_integral_mono : âˆ« t in (0)..T, a â€¢ ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (x + t â€¢ 1)â»Â¹) + b â€¢ ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (y + t â€¢ 1)â»Â¹) â‰¤ âˆ« t in (0)..T, (1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - ((a â€¢ x + b â€¢ y) + t â€¢ 1)â»Â¹ := by
    have h_integral_mono : âˆ€ t âˆˆ Set.Icc 0 T, a â€¢ ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (x + t â€¢ 1)â»Â¹) + b â€¢ ((1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - (y + t â€¢ 1)â»Â¹) â‰¤ (1 + t)â»Â¹ â€¢ (1 : HermitianMat n ğ•œ) - ((a â€¢ x + b â€¢ y) + t â€¢ 1)â»Â¹ := by
      intros t ht
      have h_inv_shift_convex : ((a â€¢ x + b â€¢ y) + t â€¢ 1)â»Â¹ â‰¤ a â€¢ (x + t â€¢ 1)â»Â¹ + b â€¢ (y + t â€¢ 1)â»Â¹ := by
        convert inv_shift_convex hx hy ha hb hab t ht.1 using 1;
      simp_all [smul_sub, â† smul_assoc ];
      rw [ show ( 1 + t ) â»Â¹ â€¢ ( 1 : HermitianMat n ğ•œ ) = ( a * ( 1 + t ) â»Â¹ ) â€¢ ( 1 : HermitianMat n ğ•œ ) + ( b * ( 1 + t ) â»Â¹ ) â€¢ ( 1 : HermitianMat n ğ•œ ) by rw [ â† add_smul, â† add_mul, hab, one_mul ] ];
      convert sub_le_sub_left h_inv_shift_convex _ using 1 ; abel_nf;
    rw [ intervalIntegral.integral_of_le hT, intervalIntegral.integral_of_le hT ];
    apply MeasureTheory.integral_mono_ae
    Â· exact ( (h_integrable hx).1.smul a |> fun h => h.add ( (h_integrable hy).1.smul b ) ) |> fun h => h.mono_measure ( MeasureTheory.Measure.restrict_mono ( Set.Ioc_subset_Ioc le_rfl le_rfl ) le_rfl );
    Â· exact h_int2.1.mono_set (Set.Ioc_subset_Ioc le_rfl le_rfl)
    Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_integral_mono t <| Set.Ioc_subset_Icc_self ht;
  convert h_integral_mono using 1;
  rw [ intervalIntegral.integral_add ( by exact (h_integrable hx).smul a ) ( by exact (h_integrable hy).smul b ), intervalIntegral.integral_smul, intervalIntegral.integral_smul ]
  rw [logApprox, logApprox]

/--
The matrix logarithm is operator concave.
-/
theorem log_concave {x y : HermitianMat n ğ•œ} (hx : x.mat.PosDef) (hy : y.mat.PosDef)
    â¦ƒa b : â„â¦„ (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) (hab : a + b = 1) :
    a â€¢ x.log + b â€¢ y.log â‰¤ (a â€¢ x + b â€¢ y).log := by
  apply le_of_tendsto_of_tendsto (b := .atTop) (f := fun T => a â€¢ x.logApprox T + b â€¢ y.logApprox T) (g := (a â€¢ x + b â€¢ y).logApprox)
  Â· exact ((tendsto_const_nhds.smul (tendsto_logApprox hx)).add (tendsto_const_nhds.smul (y.tendsto_logApprox hy)))
  Â· apply tendsto_logApprox
    exact Matrix.PosDef.Convex hx hy ha hb hab
  Â· rw [Filter.EventuallyLE, Filter.eventually_atTop]
    exact âŸ¨0, logApprox_concave hx hy ha hb habâŸ©

/-
The logarithm of the Kronecker product of two diagonal Hermitian matrices is the sum of the Kronecker products of their logarithms with the identity matrix.
-/
open HermitianMat
open scoped HermitianMat

lemma log_kron_diagonal {m n ğ•œ : Type*} [Fintype m] [DecidableEq m] [Fintype n] [DecidableEq n] [RCLike ğ•œ]
    {dâ‚ : m â†’ â„} {dâ‚‚ : n â†’ â„} (hâ‚ : âˆ€ i, 0 < dâ‚ i) (hâ‚‚ : âˆ€ j, 0 < dâ‚‚ j) :
    (diagonal ğ•œ dâ‚ âŠ—â‚– diagonal ğ•œ dâ‚‚).log =
    (diagonal ğ•œ dâ‚).log âŠ—â‚– 1 + 1 âŠ—â‚– (diagonal ğ•œ dâ‚‚).log := by
  have h_eq : (diagonal ğ•œ dâ‚ âŠ—â‚– diagonal ğ•œ dâ‚‚) = (diagonal ğ•œ (fun (i : m Ã— n) => dâ‚ i.1 * dâ‚‚ i.2)) := by
    exact kronecker_diagonal dâ‚ dâ‚‚
  convert congr_arg _ h_eq using 1;
  -- By definition of logarithm, we can rewrite the right-hand side.
  have h_rhs : (diagonal ğ•œ (fun (i : m Ã— n) => dâ‚ i.1 * dâ‚‚ i.2)).log =
    (diagonal ğ•œ (fun (i : m Ã— n) => Real.log (dâ‚ i.1) + Real.log (dâ‚‚ i.2))) := by
      have h_eq : (diagonal ğ•œ (fun (i : m Ã— n) => dâ‚ i.1 * dâ‚‚ i.2)).log = cfc (diagonal ğ•œ (fun (i : m Ã— n) => dâ‚ i.1 * dâ‚‚ i.2)) (fun x => Real.log x) := by
        exact rfl;
      rw [ h_eq, cfc_diagonal ];
      exact congr_arg _ ( funext fun i => Real.log_mul ( ne_of_gt ( hâ‚ i.1 ) ) ( ne_of_gt ( hâ‚‚ i.2 ) ) );
  rw [ h_rhs ];
  have h_rhs : (diagonal ğ•œ (fun (i : m Ã— n) => Real.log (dâ‚ i.1) + Real.log (dâ‚‚ i.2))) =
    (diagonal ğ•œ (fun (i : m Ã— n) => Real.log (dâ‚ i.1))) + (diagonal ğ•œ (fun (i : m Ã— n) => Real.log (dâ‚‚ i.2))) := by
      ext1
      simp [ diagonal ]
  rw [ h_rhs ];
  congr! 1;
  Â· rw [ show ( diagonal ğ•œ dâ‚ |> log ) = diagonal ğ•œ ( Real.log âˆ˜ dâ‚ ) from ?_ ];
    Â· convert kronecker_diagonal ( Real.log âˆ˜ dâ‚ ) 1 using 1;
      all_goals try infer_instance;
      Â· congr! 1;
        exact Eq.symm diagonal_one;
      Â· simp
    Â· exact cfc_diagonal Real.log dâ‚
  Â· have h_rhs : (diagonal ğ•œ dâ‚‚).log = (diagonal ğ•œ (fun (i : n) => Real.log (dâ‚‚ i))) := by
      exact cfc_diagonal Real.log dâ‚‚
    rw [ h_rhs ];
    convert kronecker_diagonal 1 ( fun i => Real.log ( dâ‚‚ i ) ) using 1;
    all_goals try infer_instance;
    Â· exact congr_argâ‚‚ _ ( diagonal_one.symm ) rfl;
    Â· simp

/--
The logarithm of a Hermitian matrix conjugated by a unitary matrix is the conjugate of the logarithm.
-/
lemma log_conj_unitary (A : HermitianMat n ğ•œ) (U : Matrix.unitaryGroup n ğ•œ) :
    (A.conj U.val).log = A.log.conj U.val :=
  cfc_conj_unitary _ Real.log U

open RealInnerProductSpace in
theorem inner_log_smul_of [NonSingular A] {x : â„} (hx : x â‰  0) :
    âŸª(x â€¢ A).log, BâŸ« = Real.log x * B.trace + âŸªA.log, BâŸ« := by
  simp [log_smul hx, inner_add_left]

section kron

lemma log_kron_diagonal_with_proj {dâ‚ : m â†’ â„} {dâ‚‚ : n â†’ â„}  :
    (diagonal ğ•œ dâ‚ âŠ—â‚– diagonal ğ•œ dâ‚‚).log =
    (diagonal ğ•œ dâ‚).log âŠ—â‚– (diagonal ğ•œ dâ‚‚).supportProj +
    (diagonal ğ•œ dâ‚).supportProj âŠ—â‚– (diagonal ğ•œ dâ‚‚).log := by
  have h_diag_kron : (diagonal ğ•œ dâ‚ âŠ—â‚– diagonal ğ•œ dâ‚‚).log = diagonal ğ•œ (fun i â†¦ Real.log (dâ‚ i.1 * dâ‚‚ i.2)) := by
    rw [kronecker_diagonal, log]
    exact cfc_diagonal _ _
  simp_all [ HermitianMat.ext_iff, cfc_diagonal, log, supportProj_eq_cfc ];
  ext âŸ¨i, jâŸ© âŸ¨i', j'âŸ©
  by_cases hi' : i = i'; swap
  Â· simp [hi']
  by_cases hj' : j = j'; swap
  Â· simp [hj']
  simp [hi', hj']
  split_ifs <;> simp_all [Real.log_mul]

variable {A : HermitianMat m ğ•œ} {B : HermitianMat n ğ•œ}

/--
Generalization of `HermitianMat.log_kron` for possibly singular matrices.
-/
lemma log_kron_with_proj : (A âŠ—â‚– B).log = A.log âŠ—â‚– B.supportProj + A.supportProj âŠ—â‚– B.log := by
  obtain âŸ¨UA, DA, rflâŸ© : âˆƒ UA : Matrix.unitaryGroup m ğ•œ, âˆƒ DA, A = (diagonal ğ•œ DA).conj UA.val :=
    âŸ¨_, _, eq_conj_diagonal AâŸ©
  obtain âŸ¨UB, DB, rflâŸ© : âˆƒ UB : Matrix.unitaryGroup n ğ•œ, âˆƒ DB , B = (diagonal ğ•œ DB).conj UB.val :=
    âŸ¨_, _, eq_conj_diagonal BâŸ©
  rw [â† kronecker_conj, log_conj_unitary _ âŸ¨_, Matrix.kronecker_mem_unitary UA.2 UB.2âŸ©]
  rw [log_kron_diagonal_with_proj, map_add (conj _)]
  congr 1
  <;> rw [supportProj_eq_cfc, supportProj_eq_cfc, cfc_conj_unitary, log_conj_unitary, kronecker_conj]

/--
The matrix logarithm of the Kronecker product of two nonsingular Hermitian matrices is
the sum of the Kronecker products of their logarithms with the identity matrix.
-/
theorem log_kron [NonSingular A] [NonSingular B] : (A âŠ—â‚– B).log = A.log âŠ—â‚– 1 + 1 âŠ—â‚– B.log := by
  simp [log_kron_with_proj]

end kron
