import QuantumInfo.ForMathlib.Matrix
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.ExpLog
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow.Basic
import Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus
import Mathlib.Analysis.Matrix
import Mathlib.Tactic.Clean

section IsMaximalSelfAdjoint

/- We want to have `HermitianMat.trace` give ùïú when ùïú is already a TrivialStar field, but give the "clean" type
otherwise -- for instance, ‚Ñù when the input field is ‚ÑÇ. This typeclass lets us do so. -/
class IsMaximalSelfAdjoint (R : outParam Type*) (Œ± : Type*) [Star Œ±] [Star R] [CommSemiring R]
    [Semiring Œ±] [TrivialStar R] [Algebra R Œ±] where
  selfadjMap : Œ± ‚Üí+ R
  selfadj_smul : ‚àÄ (r : R) (a : Œ±), selfadjMap (r ‚Ä¢ a) = r * (selfadjMap a)
  selfadj_algebra : ‚àÄ {a : Œ±}, IsSelfAdjoint a ‚Üí algebraMap _ _ (selfadjMap a) = a

/-- Every `TrivialStar` `CommSemiring` is its own maximal self adjoints. -/
instance instTrivialStar_IsMaximalSelfAdjoint [Star R] [TrivialStar R] [CommSemiring R] : IsMaximalSelfAdjoint R R where
  selfadjMap := AddMonoidHom.id R
  selfadj_smul _ __ := rfl
  selfadj_algebra {_} _ := rfl

/-- ‚Ñù is the maximal self adjoint elements over RCLike -/
instance instRCLike_IsMaximalSelfAdjoint [RCLike Œ±] : IsMaximalSelfAdjoint ‚Ñù Œ± where
  selfadjMap := RCLike.re
  selfadj_smul := RCLike.smul_re
  selfadj_algebra := RCLike.conj_eq_iff_re.mp

end IsMaximalSelfAdjoint
---------

/-- The type of Hermitian matrices, as a `Subtype`. Equivalent to a `Matrix n n Œ±` bundled
with the fact that `Matrix.IsHermitian`. -/
abbrev HermitianMat (n : Type*) (Œ± : Type*) [AddGroup Œ±] [StarAddMonoid Œ±] :=
  (selfAdjoint (Matrix n n Œ±) : Type (max u_1 u_2))

namespace HermitianMat

variable {Œ± : Type*} {n : Type*}

section addgroup

variable [AddGroup Œ±] [StarAddMonoid Œ±]

theorem eq_IsHermitian : HermitianMat n Œ±  = { m : Matrix n n Œ± // m.IsHermitian} := by
  rfl

@[coe, reducible] def toMat : HermitianMat n Œ± ‚Üí Matrix n n Œ± :=
  Subtype.val

instance : Coe (HermitianMat n Œ±) (Matrix n n Œ±) := ‚ü®toMat‚ü©

@[simp]
theorem val_eq_coe (A : HermitianMat n Œ±) : A.val = A := by
  rfl

/-- Alias for HermitianMat.property or HermitianMat.2, this gets the fact that the value
  is actually `IsHermitian`.-/
theorem H (A : HermitianMat n Œ±) : A.toMat.IsHermitian :=
  A.2

@[ext] protected theorem ext {A B : HermitianMat n Œ±} : A.val = B.val ‚Üí A = B :=
  Subtype.eq

instance instFun : FunLike (HermitianMat n Œ±) n (n ‚Üí Œ±) where
  coe M := (M : Matrix n n Œ±)
  coe_injective' _ _ h := HermitianMat.ext h

instance instStar : Star (HermitianMat n Œ±) :=
  ‚ü®(¬∑)‚ü©

instance instTrivialStar : TrivialStar (HermitianMat n Œ±) :=
  ‚ü®(refl ¬∑)‚ü©

end addgroup
section commring

variable [CommRing Œ±] [StarRing Œ±] [DecidableEq n] [Fintype n]

noncomputable instance instInv : Inv (HermitianMat n Œ±) :=
  ‚ü®fun x ‚Ü¶ ‚ü®x‚Åª¬π, Matrix.IsHermitian.inv x.H‚ü©‚ü©

noncomputable instance instZPow : Pow (HermitianMat n Œ±) ‚Ñ§ :=
  ‚ü®fun x z ‚Ü¶ ‚ü®x^z, Matrix.IsHermitian.zpow x.H z‚ü©‚ü©

end commring

section trace

variable [Star R] [TrivialStar R] [Fintype n]

section star
variable [AddGroup Œ±] [StarAddMonoid Œ±] [CommSemiring R] [Semiring Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]

/-- The trace of the matrix. This requires a `IsMaximalSelfAdjoint R Œ±` instance, and then maps from
  `HermitianMat n Œ±` to `R`. This means that the trace of (say) a `HermitianMat n ‚Ñ§` gives values in ‚Ñ§,
  but that the trace of a `HermitianMat n ‚ÑÇ` gives values in ‚Ñù. The fact that traces are "automatically"
  real reduces coercions down the line. -/
def trace (A : HermitianMat n Œ±) : R :=
  IsMaximalSelfAdjoint.selfadjMap (A.toMat.trace)

/-- `HermitianMat.trace` reduces to `Matrix.trace` in the algebra.-/
theorem trace_eq_trace (A : HermitianMat n Œ±) : algebraMap R Œ± A.trace = Matrix.trace A.toMat := by
  rw [HermitianMat.trace, Matrix.trace, map_sum, map_sum]
  congr! 1
  exact IsMaximalSelfAdjoint.selfadj_algebra (Matrix.IsHermitian.apply A.H _ _)

variable [StarModule R Œ±] in
@[simp]
theorem trace_smul (A : HermitianMat n Œ±) (r : R) : (r ‚Ä¢ A).trace = r * A.trace := by
  simp [trace, Finset.mul_sum, IsMaximalSelfAdjoint.selfadj_smul]

end star
section semiring
variable [CommSemiring R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]

@[simp]
theorem trace_zero : (0 : HermitianMat n Œ±).trace = 0 := by
  simp [trace]

@[simp]
theorem trace_add (A B : HermitianMat n Œ±) : (A + B).trace = A.trace + B.trace := by
  simp [trace]

end semiring
section ring

variable [CommRing R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
@[simp]
theorem trace_neg (A : HermitianMat n Œ±) : (-A).trace = -A.trace := by
  simp [trace]

@[simp]
theorem trace_sub (A B : HermitianMat n Œ±) : (A - B).trace = A.trace - B.trace := by
  simp [trace]

end ring
end trace

section trivialstar

variable [Star Œ±] [TrivialStar Œ±] [CommSemiring Œ±] [Fintype n]

/-- `HermitianMat.trace` reduces to `Matrix.trace` when the elements are a `TrivialStar`. -/
@[simp]
theorem trace_eq_trace_trivial (A : HermitianMat n ‚Ñù) : A.trace = Matrix.trace A.toMat := by
  rw [‚Üê trace_eq_trace]
  rfl

end trivialstar

section RCLike

variable {n ùïú : Type*} [Fintype n] [RCLike ùïú]

theorem trace_eq_re_trace (A : HermitianMat n ùïú) : A.trace = RCLike.re (Matrix.trace A.toMat) := by
  rfl

/-- `HermitianMat.trace` reduces to `Matrix.trace` when the elements are `RCLike`. -/
@[simp]
theorem trace_eq_trace_rc (A : HermitianMat n ùïú) : A.trace = Matrix.trace A.toMat := by
  rw [trace, Matrix.trace, map_sum, RCLike.ofReal_sum]
  congr 1
  exact Matrix.IsHermitian.coe_re_diag A.H

end RCLike

section inner

variable [Star R] [TrivialStar R] [Fintype n]

variable [Ring Œ±] [StarAddMonoid Œ±] [CommSemiring R] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±] in
/-- The Hermitian inner product, `Tr[AB]`. This is equal to `Matrix.trace (A * B)`, but gives real
  values when the matrices are complex, using `IsMaximalSelfAdjoint`. -/
def inner (A B : HermitianMat n Œ±) : R :=
  IsMaximalSelfAdjoint.selfadjMap ((A.toMat * B.toMat).trace)

section ring

variable [CommRing R] [Ring Œ±] [StarAddMonoid Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
variable (A B : HermitianMat n Œ±)

@[simp]
theorem inner_left_neg : (-A).inner B = -A.inner B := by
  simp [inner]

@[simp]
theorem inner_right_neg : A.inner (-B) = -A.inner B := by
  simp [inner]

theorem inner_left_sub : A.inner (B - C) = A.inner B - A.inner C := by
  simp [inner, mul_sub]

theorem inner_right_sub : (A - B).inner C = A.inner C - B.inner C := by
  simp [inner, sub_mul]

@[simp]
theorem inner_zero : A.inner 0 = 0 := by
  simp [inner]

@[simp]
theorem zero_inner : HermitianMat.inner 0 A = 0 := by
  simp [inner]

theorem inner_left_distrib : A.inner (B + C) = A.inner B + A.inner C := by
  simp [inner, left_distrib]

theorem inner_right_distrib : (A + B).inner C = A.inner C + B.inner C := by
  simp [inner, right_distrib]

variable [StarModule R Œ±]

@[simp]
theorem smul_inner (r : R) : (r ‚Ä¢ A).inner B = r * A.inner B := by
  simp [inner, IsMaximalSelfAdjoint.selfadj_smul]

@[simp]
theorem inner_smul (r : R) : A.inner (r ‚Ä¢ B) = r * A.inner B := by
  simp [inner, IsMaximalSelfAdjoint.selfadj_smul]

end ring
section starring

variable [CommRing R] [Ring Œ±] [StarRing Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±] [DecidableEq n]
variable (A B : HermitianMat n Œ±)

@[simp]
theorem inner_one : A.inner 1 = A.trace := by
  simp only [inner, selfAdjoint.val_one,  mul_one, trace]

@[simp]
theorem one_inner : HermitianMat.inner 1 A = A.trace := by
  simp only [inner, one_mul, selfAdjoint.val_one, trace]

end starring
section commring

variable [CommSemiring R] [CommRing Œ±] [StarRing Œ±] [Algebra R Œ±] [IsMaximalSelfAdjoint R Œ±]
variable (A B : HermitianMat n Œ±)

/-- The inner product for Hermtian matrices is equal to the trace of the product. -/
theorem inner_eq_trace_mul : algebraMap R Œ± (A.inner B) = (A.toMat * B.toMat).trace := by
  apply IsMaximalSelfAdjoint.selfadj_algebra
  rw [IsSelfAdjoint, Matrix.trace]
  simp_rw [star_sum, Matrix.diag_apply, Matrix.mul_apply, star_sum, star_mul, mul_comm]
  rw [Finset.sum_comm]
  congr! <;> apply congrFun‚ÇÇ (H _)

theorem inner_comm : A.inner B = B.inner A := by
  rw [inner, inner, Matrix.trace_mul_comm]

end commring

--TODO: Redo this with CFC
noncomputable section RCLike

variable {n ùïú : Type*} [Fintype n] [DecidableEq n] [RCLike ùïú]

/-- Matrix power of a positive semidefinite matrix, as given by the elementwise
  real power of the diagonal in a diagonalized form.

  Note that this has the usual `Real.rpow` caveats, such as 0 to the power -1 giving 0. -/
def rpow (A : HermitianMat n ùïú) (p : ‚Ñù) : HermitianMat n ùïú :=
  ‚ü®cfc (Real.rpow ¬∑ p) A.toMat, cfc_predicate _ _‚ü©

noncomputable instance instRPow : Pow (HermitianMat n ùïú) ‚Ñù :=
  ‚ü®rpow‚ü©

open ComplexOrder in
theorem rpow_PosSemidef {A : HermitianMat n ùïú} (hA : A.val.PosSemidef) (p : ‚Ñù) : (A ^ p).val.PosSemidef := by
  --TODO: Should prove the more general versions for f mapping ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 (if hA is PSD) or ‚Ñù ‚Üí ‚Ñù‚â•0.
  change (cfc _ A.toMat).PosSemidef
  rw [A.H.cfc_eq, Matrix.IsHermitian.cfc]
  apply Matrix.PosSemidef.mul_mul_conjTranspose_same
  refine Matrix.posSemidef_diagonal_iff.mpr fun i ‚Ü¶ ?_
  rw [Function.comp_apply, RCLike.nonneg_iff]
  constructor
  ¬∑ simp only [RCLike.ofReal_re]
    exact Real.rpow_nonneg (hA.eigenvalues_nonneg i) p
  ¬∑ simp only [RCLike.ofReal_im]

/-- Matrix logarithm (base e) of a Hermitian matrix, as given by the elementwise
  real logarithm of the diagonal in a diagonalized form, using `Real.log`

  Note that this means that the nullspace of the image includes all of the nullspace of the
  original matrix. This contrasts to the standard definition, which is only defined for positive
  *definite* matrices, and the nullspace of the image is exactly the (Œª=1)-eigenspace of the
  original matrix. It coincides with the standard definition if A is positive definite. -/
def log (A : HermitianMat n ùïú) : HermitianMat n ùïú :=
  let _ : NormedRing (Matrix n n ùïú) := Matrix.frobeniusNormedRing
  let _ : NormedAlgebra ‚Ñù (Matrix n n ùïú) := Matrix.frobeniusNormedAlgebra
  ‚ü®CFC.log A.toMat, IsSelfAdjoint.log‚ü©

end RCLike
