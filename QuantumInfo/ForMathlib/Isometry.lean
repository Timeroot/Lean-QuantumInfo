import Mathlib.LinearAlgebra.Matrix.HermitianFunctionalCalculus
import Mathlib.LinearAlgebra.Matrix.Permutation

open scoped Matrix

variable {d d‚ÇÇ d‚ÇÉ R : Type*}
variable [Fintype d] [DecidableEq d] [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [Fintype d‚ÇÉ] [DecidableEq d‚ÇÉ]

variable [CommRing R] [StarRing R]

variable {ùïú : Type*} [RCLike ùïú] {A B : Matrix d d ùïú}

/-- An isometry is a matrix `A` such that `AA·¥¥ = 1`. Compare with a
unitary, which requires `AA·¥¥ = A·¥¥A = 1`. -/
def Matrix.Isometry (A : Matrix d d‚ÇÇ R) : Prop :=
  A * A·¥¥ = 1

omit [Fintype d‚ÇÇ] [DecidableEq d‚ÇÉ] in
theorem Matrix.submatrix_one_isometry {e : d‚ÇÇ ‚Üí d} {f : d‚ÇÉ ‚Üí d} (he : e.Injective) (hf : f.Bijective) :
    (submatrix (Œ± := R) 1 e f).Isometry := by
  -- Since $e$ is injective and $f$ is bijective, the submatrix of the identity matrix formed by $e$ and $f$ is a permutation matrix.
  have h_perm : ‚àÄ i j, (Matrix.submatrix (1 : Matrix d d R) e f) i j = if e i = f j then 1 else 0 := by
    -- By definition of the identity matrix, the entry (i, j) in the submatrix is 1 if e i = f j and 0 otherwise.
    simp [Matrix.submatrix, Matrix.one_apply];
  ext i j
  -- Since $e$ is injective and $f$ is bijective, the product $A * A·¥¥$ will have 1s on the diagonal and 0s elsewhere, which is the identity matrix.
  change ‚àë k, (Matrix.submatrix (1 : Matrix d d R) e f) i k * (Matrix.conjTranspose (Matrix.submatrix (1 : Matrix d d R) e f)) k j = if i = j then 1 else 0
  simp_all only [Multiset.bijective_iff_map_univ_eq_univ, submatrix_apply, conjTranspose_apply, ite_mul, one_mul,
      zero_mul]
  split
  next h =>
    subst h
    simp_all only [‚ÜìreduceIte, star_one, Finset.sum_boole]
    have h_unique : ‚àÄ i, ‚àÉ! x, f x = e i := by
      intro i
      obtain ‚ü®x, hx‚ü© : ‚àÉ x, f x = e i := by
        replace hf := congr_arg Multiset.toFinset hf; rw [ Finset.ext_iff ] at hf; specialize hf ( e i ) ; aesop;
      use x
      simp_all only [true_and]
      intro y a
      have := Fintype.bijective_iff_injective_and_card f
      aesop
    obtain ‚ü® x, hx ‚ü© := h_unique i;
    rw [ show ( Finset.univ.filter fun y => e i = f y ) = { x } from Finset.eq_singleton_iff_unique_mem.2 ‚ü® by aesop, fun y hy => hx.2 y <| Eq.symm <| Finset.mem_filter.1 hy |>.2 ‚ü© ] ; simp ( config := { decide := Bool.true } );
  next h => -- Since $e$ is injective and $e i \neq e j$, there is no $x$ such that $e i = f x$ and $e j = f x$.
    have h_no_x : ‚àÄ x : d‚ÇÉ, ¬¨(e i = f x ‚àß e j = f x) := by
      exact fun x hx => h ( he ( hx.1.trans hx.2.symm ) );
    exact Finset.sum_eq_zero fun x hx => by specialize h_no_x x; aesop

omit [DecidableEq d‚ÇÇ] in
theorem Matrix.submatrix_one_id_left_isometry {e : d‚ÇÇ ‚Üí d} (he : e.Bijective) :
    (submatrix (1 : Matrix d d R) id e).Isometry :=
  submatrix_one_isometry Function.injective_id he

omit [Fintype d‚ÇÇ] in
theorem Matrix.submatrix_one_id_right_isometry {e : d‚ÇÇ ‚Üí d} (he : e.Injective) :
    (submatrix (1 : Matrix d d R) e id).Isometry :=
  submatrix_one_isometry he Function.bijective_id

theorem Matrix.mem_unitaryGroup_iff_isometry (A : Matrix d d R) :
    A ‚àà unitaryGroup d R ‚Üî A.Isometry ‚àß A·¥¥.Isometry := by
  rw [Isometry, Isometry, and_comm, conjTranspose_conjTranspose]
  rfl

theorem Equiv.Perm.permMatrix_mem_unitaryGroup (e : Perm d) :
    e.permMatrix R ‚àà Matrix.unitaryGroup d R := by
  -- Since $e$ is a permutation, its permutation matrix $P_e$ is orthogonal, meaning $P_e * P_e^T = I$.
  have h_perm_ortho : (Equiv.Perm.permMatrix R e) * (Equiv.Perm.permMatrix R e)·µÄ = 1 := by
    ext i j; rw [ Matrix.mul_apply ] ; aesop;
  constructor
  ¬∑ simp_all only [Matrix.transpose_permMatrix]
    -- Since the conjugate transpose of a permutation matrix is the permutation matrix of the inverse permutation, we have:
    have h_conj_transpose : star (Equiv.Perm.permMatrix R e) = (Equiv.Perm.permMatrix R e)·µÄ := by
      ext i j; simp ( config := { decide := Bool.true } ) [ Equiv.Perm.permMatrix ] ; aesop;
    simp_all ( config := { decide := Bool.true } ) [ Matrix.mul_eq_one_comm ];
  ¬∑ simp_all only [Matrix.transpose_permMatrix]
    convert h_perm_ortho using 2;
    simp ( config := { decide := Bool.true } ) [ Matrix.star_eq_conjTranspose, Equiv.Perm.permMatrix ]

omit [Fintype d‚ÇÇ] [DecidableEq d‚ÇÉ] in
theorem Matrix.reindex_one_isometry (e : d ‚âÉ d‚ÇÇ) (f : d ‚âÉ d‚ÇÉ) :
    (reindex (Œ± := R) e f 1).Isometry := by
  -- Since $e$ and $f$ are bijections, the reindexing of the identity matrix by $e$ and $f$ is a permutation matrix, which is unitary.
  have h_perm : ‚àÄ (e : d ‚âÉ d‚ÇÇ) (f : d ‚âÉ d‚ÇÉ), (Matrix.reindex e f (1 : Matrix d d R)).Isometry := by
    intro e f
    simp [Matrix.Isometry];
  exact h_perm e f

omit [Fintype d] in
theorem Matrix.reindex_one_mem_unitaryGroup (e : d ‚âÉ d‚ÇÇ)  :
    reindex (Œ± := R) e e 1 ‚àà unitaryGroup d‚ÇÇ R := by
  -- The reindex of the identity matrix under an equivalence e is just the identity matrix on d‚ÇÇ.
  have h_reindex_id : Matrix.reindex e e (1 : Matrix d d R) = 1 := by
    -- By definition of reindex, the entry at (i, j) in the reindexed matrix is 1 if i = j and 0 otherwise.
    ext i j; simp [Matrix.reindex, Matrix.one_apply];
  -- Since the identity matrix is unitary, its conjugate transpose is also the identity matrix.
  simp [h_reindex_id];

omit [Fintype d‚ÇÇ] [DecidableEq d‚ÇÇ] [StarRing R] in
theorem Matrix.reindex_eq_conj (A : Matrix d d R) (e : d ‚âÉ d‚ÇÇ) : reindex e e A =
    (reindex (Œ± := R) e (.refl d) 1) * A * (reindex (Œ± := R) (.refl d) e 1) := by
  -- By definition of matrix multiplication and reindexing, we can show that the two matrices are equal.
  ext i j; simp [Matrix.mul_apply, Matrix.reindex];
  -- The inner sum simplifies to $A (e.symm i) x$ because $1 (e.symm i) x$ is $1$ if $x = e.symm i$ and $0$ otherwise.
  simp [Matrix.one_apply]

theorem Matrix.reindex_eq_conj_unitaryGroup' (A : Matrix d d R) (e : Equiv.Perm d) : reindex e e A =
    (‚ü®_, e‚Åª¬π.permMatrix_mem_unitaryGroup‚ü© : unitaryGroup d R) * A * (‚ü®_, e.permMatrix_mem_unitaryGroup‚ü© : unitaryGroup d R) := by
  ext i j;
  simp ( config := { decide := Bool.true } ) [ Matrix.mul_apply ];
  rw [ Finset.sum_eq_single ( e.symm j ) ] <;> aesop

theorem Matrix.IsHermitian.conj_isometry {A : Matrix d d R} {u : Matrix d d‚ÇÇ R}
  (hA : A.IsHermitian) (hu : u.Isometry) :
    (u·¥¥ * A * u).IsHermitian := by
  sorry

theorem Matrix.IsHermitian.eigenvalue_ext (hA : A.IsHermitian)
  (h : ‚àÄ (v : d ‚Üí ùïú) (lam : ùïú), A *·µ• v = lam ‚Ä¢ v ‚Üí B *·µ• v = lam ‚Ä¢ v) :
    A = B := by
  -- Since A is Hermitian, it is diagonalizable, and its eigenvectors form a complete basis. Therefore, for any vector v, we have Av = Bv.
  have h_diag : ‚àÄ v : d ‚Üí ùïú, (A *·µ• v) = (B *·µ• v) := by
    -- Since A is Hermitian, it is diagonalizable, and its eigenvectors form a complete basis. Therefore, for any vector v, we can express it as a linear combination of eigenvectors.
    have h_diag : ‚àÄ v : d ‚Üí ùïú, ‚àÉ (c : d ‚Üí ùïú) (lam : d ‚Üí ùïú), v = ‚àë i, c i ‚Ä¢ (Matrix.IsHermitian.eigenvectorBasis hA i) ‚àß ‚àÄ i, A *·µ• (Matrix.IsHermitian.eigenvectorBasis hA i) = lam i ‚Ä¢ (Matrix.IsHermitian.eigenvectorBasis hA i) := by
      intro v
      obtain ‚ü®c, hc‚ü© : ‚àÉ c : d ‚Üí ùïú, v = ‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i) := by
        have h_diag : ‚àÄ v : EuclideanSpace ùïú d, ‚àÉ c : d ‚Üí ùïú, v = ‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i) := by
          intro v
          set c := fun i => inner‚Çõ‚Çó ùïú (hA.eigenvectorBasis i) v
          have hv : v = ‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i) := by
            exact Eq.symm (OrthonormalBasis.sum_repr' hA.eigenvectorBasis v)
          use c;
        exact h_diag v;
      refine' ‚ü® c, fun i => ( hA.eigenvalues i ), hc, fun i => _ ‚ü©;
      convert hA.mulVec_eigenvectorBasis i;
      ext; simp ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct ];
      (expose_names; exact Eq.symm (RCLike.real_smul_eq_coe_mul (hA.eigenvalues i) (x i_1)));
    -- By linearity of A and B, we can distribute them over the sum.
    intros v
    obtain ‚ü®c, lam, hv, hlam‚ü© := h_diag v
    have hAv : A *·µ• v = ‚àë i, c i ‚Ä¢ lam i ‚Ä¢ (hA.eigenvectorBasis i) := by
      -- By linearity of matrix multiplication, we can distribute A over the sum.
      have hAv : A *·µ• (‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i)) = ‚àë i, c i ‚Ä¢ A *·µ• (hA.eigenvectorBasis i) := by
        simp ( config := { decide := Bool.true } ) [ funext_iff, Matrix.mulVec_smul ];
        simp ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _ ];
        exact fun _ => Finset.sum_comm.trans ( Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by ring );
      aesop
    have hBv : B *·µ• v = ‚àë i, c i ‚Ä¢ lam i ‚Ä¢ (hA.eigenvectorBasis i) := by
      have hBv : B *·µ• v = ‚àë i, c i ‚Ä¢ (B *·µ• (hA.eigenvectorBasis i)) := by
        -- By linearity of matrix multiplication, we can distribute $B$ over the sum.
        have hBv : B *·µ• v = B *·µ• (‚àë i, c i ‚Ä¢ (hA.eigenvectorBasis i)) := by
          rw [hv];
        simp ( config := { decide := Bool.true } ) [ hBv, funext_iff, Matrix.mulVec_smul ];
        simp ( config := { decide := Bool.true } ) [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _ ];
        exact fun _ => Finset.sum_comm.trans ( Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by ring );
      exact hBv.trans ( Finset.sum_congr rfl fun i _ => by rw [ h _ _ ( hlam i ) ] )
    rw [hAv, hBv];
  -- By the definition of matrix equality, if $A * v = B * v$ for all $v$, then $A = B$.
  apply Matrix.ext; intro i j; exact (by
  simpa using congr_fun ( h_diag ( Pi.single j 1 ) ) i)

private theorem Matrix.cfc_conj_isometry' (hA : A.IsHermitian) (f : ‚Ñù ‚Üí ‚Ñù) {u : Matrix d‚ÇÇ d ùïú}
  (hu‚ÇÅ : u.Isometry) (hu‚ÇÇ : u·¥¥.Isometry) :
    cfc f (u * A * u·¥¥) = u * (cfc f A) * u·¥¥ := by
  apply Matrix.IsHermitian.eigenvalue_ext
  ¬∑ exact cfc_predicate f (u * A * u·¥¥)
  intro v lam h
  sorry

theorem Matrix.cfc_conj_isometry (f : ‚Ñù ‚Üí ‚Ñù) {u : Matrix d‚ÇÇ d ùïú}
  (hu‚ÇÅ : u.Isometry) (hu‚ÇÇ : u·¥¥.Isometry) :
    cfc f (u * A * u·¥¥) = u * (cfc f A) * u·¥¥ := by
  by_cases hA : A.IsHermitian
  ¬∑ exact cfc_conj_isometry' hA f hu‚ÇÅ hu‚ÇÇ
  rw [cfc_apply_of_not_predicate, cfc_apply_of_not_predicate]
  ¬∑ simp
  ¬∑ exact hA
  ¬∑ contrapose! hA
    convert Matrix.IsHermitian.conj_isometry (A := u * A * u·¥¥) (u := u) hA hu‚ÇÅ
    have hu‚ÇÉ : u·¥¥ * u = 1 := by rw [‚Üê hu‚ÇÇ]; simp
    simp only [Matrix.mul_assoc, hu‚ÇÉ]
    simp [‚Üê Matrix.mul_assoc, hu‚ÇÉ]

theorem Matrix.cfc_conj_unitary (f : ‚Ñù ‚Üí ‚Ñù) (u : unitaryGroup d ùïú) :
    cfc f (u * A * u‚Åª¬π) = u * (cfc f A) * u‚Åª¬π := by
  have hu := u.prop
  rw [mem_unitaryGroup_iff_isometry] at hu
  exact Matrix.cfc_conj_isometry f hu.left hu.right

theorem Matrix.cfc_reindex (f : ‚Ñù ‚Üí ‚Ñù) (e : d ‚âÉ d‚ÇÇ) :
    cfc f (reindex e e A) = reindex e e (cfc f A) := by
  rw [reindex_eq_conj, reindex_eq_conj]
  convert Matrix.cfc_conj_isometry f (u := (Matrix.reindex e (Equiv.refl d) : Matrix d d ùïú ‚Üí Matrix d‚ÇÇ d ùïú) 1) ?_ ?_
  ¬∑ simp
  ¬∑ simp
  ¬∑ apply reindex_one_isometry
  ¬∑ rw [conjTranspose_reindex, conjTranspose_one]
    apply reindex_one_isometry
